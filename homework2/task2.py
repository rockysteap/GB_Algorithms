from service import header, print_symbolic_list_info, is_digits_list
from service import running_time
from service import print_digits_list_data_or_info
from quick_sort import quick_sort
from counting_sort import counting_sort
from heap_sort import heap_sort

def task2():
    print("""
1. Аналитически обосновать в каких случаях эффективнее применять 
   быструю сортировку, а когда сортировку подсчетом.

Быстрая сортировка. Сложность O(nlog(n)).
Это еще один алгоритм типа «разделяй и властвуй». Он работает рекурсивно и предпочтителен 
для больших массивов данных. Его применяют, когда порядок равных элементов не важен. 
Быстрая сортировка не является стабильным алгоритмом, а это означает, что после того, 
как набор данных упорядочен, элементы, значения которых равны, не гарантируют, что 
они будут в том же порядке, что и исходный набор данных. Быстрая сортировка является простой 
сортировкой 'на месте', что означает, что она не нуждается в дополнительном хранилище. 
При неудачных входных данных может сильно деградировать по скорости до O(n**2).
      
Сортировка подсчетом. Сложность O(n).
Отлично подойдет для сортировки большого объема результатов в определённом известном 
диапазоне (например, это диапазон работы какого-то датчика), и когда такой диапазон 
гораздо меньше общего количества элементов массива. Так как эта сортировка не использует 
сравнений, то её реализация требует вспомогательный массив для заполнения результатами 
поиска, что требует выделения дополнительной памяти. Диапазон данных должен быть предопределен, 
иначе для получения минимального и максимального значений потребуются дополнительные циклы.
Это стабильная сортировка, при которой, если два элемента имеют одинаковый ключ, они должны 
иметь такое же относительное положение в отсортированных выходных данных, как и во входных.

Пирамидальная сортировка (сортировка кучей). Сложность O(nlog(n)).
Комплексный алгоритм, структура, используемая в пирамидальной сортировке называется 
двоичная куча. Его типичная реализация не стабильна, но может быть таковой сделана. 
Алгоритм пирамидальной сортировки имеет ограниченное применение, потому что quick 
sort (быстрая сортировка) и merge sort (сортировка слиянием) на практике лучше. 
Тем не менее, сама структура данных кучи используется довольно часто. Но из-за сложности 
алгоритма выигрыш получается только на больших n.
    """)

    input('Нажмите Enter для продолжения...')

    print("""
2. Произвести ряд экспериментов с различной длиной массивов и различным диапазоном значений.
   Оценить и интерпретировать результаты экспериментов, соотнести с теоретическими выкладками.
        """)
    """
    test_lst1 = advanced_list_gen(query=False, lower_n=10_000_000, upper_n=10_000_000,
                                  lower_start=-2_000_000, lower_end=-1_000_000, 
                                  upper_start=1_000_000, upper_end=2_000_000)
    input('Нажмите Enter для продолжения и подождите...')
    init_experiment(test_lst1)
    """
    stored_experiment1()
    input('Нажмите Enter для продолжения...')
    """
    test_lst2 = advanced_list_gen(query=False, lower_n=10_000_000, upper_n=10_000_000,
                                  lower_start=-2_000, lower_end=-1_000,
                                  upper_start=1_000, upper_end=2_000)
    input('Нажмите Enter для продолжения и подождите...')
    init_experiment(test_lst2)
    """
    stored_experiment2()
    input('Нажмите Enter для продолжения...')
    """
    test_lst3 = advanced_list_gen(query=False, lower_n=10_000_000, upper_n=10_000_000,
                                  lower_start=-2, lower_end=-1, upper_start=1, upper_end=2,
                                  symbols=3, word_min_len=1, word_max_len=20)
    input('Нажмите Enter для продолжения и подождите...')
    init_experiment(test_lst3)
    """
    stored_experiment3()
    input('Нажмите Enter для продолжения...')

    summary()
    input('Нажмите Enter для продолжения...')

def init_experiment(test_lst):
    is_digit = is_digits_list(test_lst)
    header(' Используем алгоритмы сортировки ')
    print()
    header(' Быстрая сортировка ')
    print_digits_list_data_or_info(test_lst) if is_digit else print_symbolic_list_info(test_lst)
    res_lst = running_time(quick_sort, test_lst)
    print_digits_list_data_or_info(res_lst, False) if is_digit else None
    print()

    header(' Сортировка подсчетом ')
    print_digits_list_data_or_info(test_lst) if is_digit else print_symbolic_list_info(test_lst)
    if is_digit:
        res_lst = running_time(counting_sort, test_lst)
    else:
        print('Данная реализация сортировки подсчетом применяется только к\n'
              'цифровому списку')
    print_digits_list_data_or_info(res_lst, False) if is_digit else None
    print()

    header(' Пирамидальная сортировка ')
    print_digits_list_data_or_info(test_lst) if is_digit else print_symbolic_list_info(test_lst)
    running_time(heap_sort, test_lst)
    print_digits_list_data_or_info(res_lst, False) if is_digit else None
    print()

    header(' Встроенная сортировка (sorted) ')
    print_digits_list_data_or_info(test_lst) if is_digit else print_symbolic_list_info(test_lst)
    res_lst = running_time(sorted, test_lst)
    print_digits_list_data_or_info(res_lst, False) if is_digit else None

    header()
    print()


def stored_experiment1():
    print("""
Эксперимент 1
------------------- Сгенерирован список -------------------
  Использованы следующие символы:
  0123456789
------------------- Параметры генерации -------------------
  Нижний диапазон: -1,468,915, верхний диапазон: 1,732,202
  Всего элементов 10,000,000
------------------------------------------------------------

------------- Используем алгоритмы сортировки -------------
-------------------- Быстрая сортировка --------------------
Кол-во элементов 10,000,000 от -1,468,915 до 1,732,202
Выполнение за 35.99649477005005 сек.

------------------- Сортировка подсчетом -------------------
Кол-во элементов 10,000,000 от -1,468,915 до 1,732,202
Выполнение за 3.1373801231384277 сек.

----------------- Пирамидальная сортировка -----------------
Кол-во элементов 10,000,000 от -1,468,915 до 1,732,202
Выполнение за 85.32147145271301 сек.

-------------- Встроенная сортировка (sorted) --------------
Кол-во элементов 10,000,000 от -1,468,915 до 1,732,202
Выполнение за 0.7263648509979248 сек.
------------------------------------------------------------
""")


def stored_experiment2():
    print("""
Эксперимент 2
------------------- Сгенерирован список -------------------
  Использованы следующие символы:
  0123456789
------------------- Параметры генерации -------------------
  Нижний диапазон: -1,924, верхний диапазон: 1,290
  Всего элементов 10,000,000
------------------------------------------------------------

------------- Используем алгоритмы сортировки -------------
-------------------- Быстрая сортировка --------------------
Кол-во элементов 10,000,000 от -1,924 до 1,290
Выполнение за 19.161808013916016 сек.

------------------- Сортировка подсчетом -------------------
Кол-во элементов 10,000,000 от -1,924 до 1,290
Выполнение за 1.5551059246063232 сек.

----------------- Пирамидальная сортировка -----------------
Кол-во элементов 10,000,000 от -1,924 до 1,290
Выполнение за 74.73213005065918 сек.

-------------- Встроенная сортировка (sorted) --------------
Кол-во элементов 10,000,000 от -1,924 до 1,290
Выполнение за 0.6048533916473389 сек.
------------------------------------------------------------
    """)


def stored_experiment3():
    print("""
Эксперимент 3    
------------------- Сгенерирован список -------------------
      Использованы следующие символы:
  0123456789
  abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ
  !"#$%&'()*+,-./:;<=>?@[\]^_`{|}~
------------------- Параметры генерации -------------------
  Количество элементов каждого слова от 1 до 20
  Всего элементов 10,000,000
------------------------------------------------------------

------------- Используем алгоритмы сортировки -------------
-------------------- Быстрая сортировка --------------------
Кол-во элементов 10,000,000 длиной от 1 до 20
Выполнение за 45.16387057304382 сек.

------------------- Сортировка подсчетом -------------------
Кол-во элементов 10,000,000 длиной от 1 до 20
Данная реализация сортировки подсчетом применяется только к
цифровому списку

----------------- Пирамидальная сортировка -----------------
Кол-во элементов 10,000,000 длиной от 1 до 20
Выполнение за 97.64074611663818 сек.

-------------- Встроенная сортировка (sorted) --------------
Кол-во элементов 10,000,000 длиной от 1 до 20
Выполнение за 1.1462881565093994 сек.
------------------------------------------------------------
    """)


def summary():
    header(' Сводные наблюдения: ' )
    print("""Легко заметить, что при уменьшении диапазона и быстрая, и сортировка 
подсчетом практически удвоили свой результат, когда как сортировка
кучей улучшила время примерно лишь на 15%.

Безоговорочным лидером работы с цифровым списком стала сортировка
подсчетом. Когда как в случае необходимости обработать символьный
список, наша реализация сортировки подсчетом помочь не сможет, 
что забирает у нее право называться универсальной.  

Самостоятельная реализация быстрой сортировки средствами языка Python
оставляет желать лучшего. Встроенная в стандартные средства сортировка,
реализованная на С++ показывает, что такого рода алгоритмы быстрее всего
работают будучи реализованными на более низкоуровневых языках.
    """)
